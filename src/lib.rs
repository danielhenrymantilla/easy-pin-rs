/// The main `proc_macro_attribute`
pub use ::easy_pin_proc_macro::easy_pin;

/// Stuff exported under a name collision with the proc_macro_attribute
#[doc(hidden)] pub mod easy_pin {pub use super::{
    core,
    PinDrop,
    PinSensitive,
};}

pub
trait PinDrop : Drop {
    /// # Safety
    ///
    ///   - `PinDrop::drop_pinned` must never be called directly,
    ///     only by `Drop::drop` (_e.g._, generated by `#[easy_pin(Drop)]`)
    ///
    ///   - However, **it must always be safe to call on `Drop`**, even when
    ///     `Self` has never been behind a `Pin`-ned pointer.
    unsafe
    fn drop_pinned (self: core::pin::Pin<&'_ mut Self>);
}

#[derive(
    Debug,
    // Clone, /* `!Unpin` stuff should not have #[derive(Clone)] accessible */
    PartialEq, Eq,
    PartialOrd, Ord,
)]
#[repr(transparent)]
pub
struct PinSensitive<T> {
    inner: T,
    _marker: core::marker::PhantomPinned,
}

impl<T : Default> Default for PinSensitive<T> {
    #[inline]
    fn default () -> Self
    {
        Self {
            inner: Default::default(),
            _marker: core::marker::PhantomPinned,
        }
    }
}

impl<T> PinSensitive<T> {
    #[inline]
    pub
    fn new (value: T) -> Self
    {
        Self {
            inner: value,
            _marker: core::marker::PhantomPinned,
        }
    }

    #[inline]
    pub
    fn pinned_address<'__> (
        self: core::pin::Pin<&'__ Self>,
    ) -> core::ptr::NonNull<T> // variance is justified because *const
    {
        (&self.inner).into()
    }
}

impl<T> core::ops::Deref for PinSensitive<T> {
    type Target = T;

    #[inline]
    fn deref (self: &'_ Self) -> &'_ Self::Target
    {
        &self.inner
    }
}
impl<T> core::ops::DerefMut for PinSensitive<T> {
    #[inline]
    fn deref_mut (self: &'_ mut Self) -> &'_ mut Self::Target
    {
        &mut self.inner
    }
}

#[doc(hidden)]
pub use ::core;
